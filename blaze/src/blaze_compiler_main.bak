// BLAZE COMPILER MAIN - Integrates all components
// Compiles Blaze source to x86-64 machine code

#include "blaze_internals.h"

// Forward declare write to avoid implicit declaration warning
// write() is declared in blaze_stdlib.h

// External function declarations from all modules
extern uint32_t lex_blaze(const char* input, uint32_t len, Token* output);
extern uint16_t parse_blaze(Token* tokens, uint32_t count, ASTNode* node_pool, 
                           uint32_t pool_size, char* string_pool, const char* source);
// These are declared in blaze_internals.h with correct signatures
extern void generate_temporal_function(CodeBuffer* code, ASTNode* nodes, uint16_t root_idx,
                                     uint16_t node_count, char* string_pool,
                                     ExecutionStep* execution_plan, uint32_t plan_size);
extern void generate_array4d_create(CodeBuffer* buf, ASTNode* nodes, uint16_t node_idx, 
                                   SymbolTable* symbols, char* string_pool);
extern void generate_array4d_access(CodeBuffer* buf, ASTNode* nodes, uint16_t node_idx,
                                   SymbolTable* symbols, char* string_pool, bool is_lvalue);
extern void generate_elf_executable(uint8_t* machine_code, uint32_t code_size, 
                                   const char* output_filename);
extern void generate_pe_executable(uint8_t* machine_code, uint32_t code_size,
                                  const char* output_filename);
extern Platform get_default_platform();
extern void emit_platform_exit(CodeBuffer* buf, Platform platform, int exit_code);
extern void emit_sub_reg_imm32(CodeBuffer* buf, X64Register reg, int32_t value);
extern void gen_timeline_operation(uint8_t* output, uint32_t* offset, ASTNode* node, 
                                  char* string_pool, SymbolTable* symbols);
extern void gen_output_method(uint8_t* output, uint32_t* offset, ASTNode* node,
                             char* string_pool, SymbolTable* symbols);
extern void gen_inline_asm(uint8_t* output, uint32_t* offset, ASTNode* node,
                          char* string_pool, SymbolTable* symbols);

// Simple file reading (no stdlib)
static uint32_t read_file(const char* filename, char* buffer, uint32_t max_size) {
    // Use syscalls to read file
    int fd;
    __asm__ volatile (
        "movq $2, %%rax\n"       // sys_open
        "movq %1, %%rdi\n"       // filename
        "movq $0, %%rsi\n"       // O_RDONLY
        "movq $0, %%rdx\n"       // mode
        "syscall\n"
        "movl %%eax, %0\n"
        : "=r"(fd)
        : "r"(filename)
        : "rax", "rdi", "rsi", "rdx"
    );
    
    if (fd < 0) return 0;
    
    ssize_t bytes_read;
    __asm__ volatile (
        "movq $0, %%rax\n"       // sys_read
        "movl %1, %%edi\n"       // fd
        "movq %2, %%rsi\n"       // buffer
        "movq %3, %%rdx\n"       // count
        "syscall\n"
        "movq %%rax, %0\n"
        : "=r"(bytes_read)
        : "r"(fd), "r"(buffer), "r"((size_t)max_size - 1)
        : "rax", "rdi", "rsi", "rdx"
    );
    
    // Close file
    __asm__ volatile (
        "movq $3, %%rax\n"       // sys_close
        "movl %0, %%edi\n"       // fd
        "syscall\n"
        :
        : "r"(fd)
        : "rax", "rdi"
    );
    
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        return bytes_read;
    }
    
    return 0;
}

// Write output file
static void write_output(const char* filename, uint8_t* code, uint32_t size) {
    // In real implementation, would create ELF executable
    // For now, just print summary
    write(1, "Generated ", 10);
    char size_str[16];
    int idx = 0;
    uint32_t n = size;
    do {
        size_str[idx++] = '0' + (n % 10);
        n /= 10;
    } while (n > 0);
    while (idx > 0) {
        write(1, &size_str[--idx], 1);
    }
    write(1, " bytes of machine code\n", 23);
}

// write() is now provided by blaze_stdlib.c

// Main compiler entry point
int main(int argc, char** argv) {
    // Allocate working buffers statically to avoid stack overflow
    static char source_buffer[32768];
    static Token tokens[MAX_TOKENS];
    static ASTNode nodes[4096];
    static char string_pool[4096];
    static uint8_t code_buffer[MAX_CODE_SIZE];
    static ExecutionStep execution_plan[1024];
    
    // Clear buffers to avoid garbage
    for (int i = 0; i < 32768; i++) {
        source_buffer[i] = 0;
    }
    write(1, "Source buffer cleared!\n", 23);
    
    write(1, "Clearing tokens...\n", 19);
    for (int i = 0; i < MAX_TOKENS; i++) {
        tokens[i].type = TOK_EOF;
        tokens[i].start = 0;
        tokens[i].len = 0;
        tokens[i].line = 0;
    }
    
    write(1, "Clearing critical buffers...\n", 29);
    
    // Clear at least first node to avoid parser issues
    write(1, "Clearing first node...\n", 23);
    nodes[0].type = 0;
    write(1, "Node type cleared...\n", 21);
    for (int j = 0; j < sizeof(nodes[0].data); j++) {
        ((uint8_t*)&nodes[0].data)[j] = 0;
    }
    write(1, "First node cleared!\n", 20);
    
    // Clear string pool - it's small
    write(1, "Clearing string pool...\n", 24);
    write(1, "String pool address: ", 21);
    print_num((long)string_pool);
    write(1, "\n", 1);
    for (int i = 0; i < 4096; i++) {
        if (i % 1024 == 0) {
            write(1, "  SP ", 5);
            print_num(i);
            write(1, "\n", 1);
        }
        string_pool[i] = 0;
    }
    write(1, "String pool cleared!\n", 21);
    
    // Clear first part of code buffer
    write(1, "Clearing code buffer start...\n", 30);
    for (int i = 0; i < 1024; i++) code_buffer[i] = 0;
    write(1, "Code buffer start cleared!\n", 27);
    
    // Clear execution plan - it's critical
    write(1, "Clearing execution plan...\n", 27);
    for (int i = 0; i < 1024; i++) {
        execution_plan[i].node_idx = 0;
        execution_plan[i].creates_past_value = false;
        execution_plan[i].requires_future_value = false;
        execution_plan[i].temporal_order = 0;
        execution_plan[i].dep_count = 0;
    }
    write(1, "Execution plan cleared!\n", 24);
    
    // TODO: Fix stack issues with clearing large buffers
    /*
    write(1, "Clearing nodes...\n", 18);
    for (int i = 0; i < 4096; i++) {
        nodes[i].type = 0;
        // Clear the union - safe because all members start at same offset
        for (int j = 0; j < sizeof(nodes[i].data); j++) {
            ((uint8_t*)&nodes[i].data)[j] = 0;
        }
    }
    
    write(1, "Clearing string pool...\n", 24);
    for (int i = 0; i < 4096; i++) string_pool[i] = 0;
    
    write(1, "Clearing code buffer...\n", 24);
    write(1, "Code buffer address: ", 21);
    print_num((long)code_buffer);
    write(1, ", size: ", 8);
    print_num(MAX_CODE_SIZE);
    write(1, "\n", 1);
    for (int i = 0; i < MAX_CODE_SIZE; i++) {
        if (i % 16384 == 0) {
            write(1, "  Cleared code ", 15);
            print_num(i);
            write(1, " bytes\n", 7);
        }
        code_buffer[i] = 0;
    }
    write(1, "Code buffer cleared!\n", 21);
    
    write(1, "Clearing execution plan...\n", 27);
    for (int i = 0; i < 1024; i++) {
        execution_plan[i].node_idx = 0;
        execution_plan[i].creates_past_value = false;
        execution_plan[i].requires_future_value = false;
        execution_plan[i].temporal_order = 0;
        execution_plan[i].dep_count = 0;
        for (int j = 0; j < 8; j++) execution_plan[i].dependencies[j] = 0;
    }
    */
    
    write(1, "All buffers cleared.\n", 21);
    
    // Parse command line arguments
    write(1, "Parsing command line...\n", 24);
    const char* filename = NULL;
    const char* output_name = "output";
    write(1, "Getting default platform...\n", 28);
    Platform target_platform = get_default_platform();
    write(1, "Got platform\n", 13);
    bool generate_both = false;
    
    write(1, "Starting arg loop...\n", 21);
    write(1, "argc=", 5);
    print_num(argc);
    write(1, "\n", 1);
    for (int i = 1; i < argc; i++) {
        write(1, "Processing arg: ", 16);
        // Calculate length manually
        int arglen = 0;
        while (argv[i][arglen]) arglen++;
        write(1, argv[i], arglen);
        write(1, "\n", 1);
        if (argv[i][0] == '-') {
            if (argv[i][1] == 'o' && i + 1 < argc) {
                output_name = argv[++i];
            } else if (argv[i][1] == 'p' && i + 1 < argc) {
                i++;
                if (argv[i][0] == 'w') target_platform = PLATFORM_WINDOWS;
                else if (argv[i][0] == 'l') target_platform = PLATFORM_LINUX;
                else if (argv[i][0] == 'm') target_platform = PLATFORM_MACOS;
            } else if (argv[i][1] == 'a') {
                generate_both = true;
            }
        } else {
            filename = argv[i];
        }
    }
    write(1, "Arg loop done\n", 14);
    
    // Check if filename was provided
    if (!filename) {
        write(2, "Error: No input file specified\n", 31);
        write(2, "Usage: blaze <source.blaze> [-o output] [-p w|l|m]\n", 51);
        return 1;
    }
    
    // Read source file
    write(1, "Reading file: ", 14);
    int flen = 0;
    while (filename[flen]) flen++;
    write(1, filename, flen);
    write(1, "\n", 1);
    
    uint32_t source_len = read_file(filename, source_buffer, sizeof(source_buffer));
    
    write(1, "File read complete\n", 19);
    write(1, "Source length: ", 15);
    print_num(source_len);
    write(1, " bytes\n", 7);
    
    if (source_len == 0) {
        write(2, "Error: Could not read source file\n", 34);
        return 1;
    }
    
    // Phase 1: Lexical analysis
    write(1, "Phase 1: Lexing...\n", 19);
    uint32_t token_count = lex_blaze(source_buffer, source_len, tokens);
    write(1, "Lexing complete. Token count: ", 30);
    print_num(token_count);
    write(1, "\n", 1);
    
    if (token_count == 0) {
        write(2, "Error: Lexical analysis failed\n", 31);
        return 1;
    }
    
    // Debug: print tokens if requested
    print_str("DEBUG: About to call debug_print_tokens\n");
    print_str("  token_count value: ");
    print_num((long)token_count);
    print_str("\n");
    print_str("  token_count address: ");
    print_num((long)(unsigned long)&token_count);
    print_str("\n");
    print_str("  tokens address: ");
    print_num((long)(unsigned long)tokens);
    print_str("\n");
    print_str("  source_buffer address: ");
    print_num((long)(unsigned long)source_buffer);
    print_str("\n");
    debug_print_tokens(tokens, token_count, source_buffer);
    
    // Phase 2: Parsing
    write(1, "Phase 2: Parsing...\n", 20);
    
    // Debug: show first few chars of source
    write(1, "Source: '", 9);
    for (int i = 0; i < 20 && i < source_len; i++) {
        write(1, &source_buffer[i], 1);
    }
    write(1, "'\n", 2);
    
    // Debug: show filename
    write(1, "File: ", 6);
    uint32_t fname_len = 0;
    while (filename[fname_len] && fname_len < 100) fname_len++;
    write(1, filename, fname_len);
    write(1, "\n", 1);
    
    uint16_t root_node = parse_blaze(tokens, token_count, nodes, 4096, 
                                     string_pool, source_buffer);
    
    // Debug output
    char debug_msg[100];
    int len = 0;
    debug_msg[len++] = 'P';
    debug_msg[len++] = 'a';
    debug_msg[len++] = 'r';
    debug_msg[len++] = 's';
    debug_msg[len++] = 'e';
    debug_msg[len++] = ' ';
    debug_msg[len++] = 'r';
    debug_msg[len++] = 'e';
    debug_msg[len++] = 't';
    debug_msg[len++] = 'u';
    debug_msg[len++] = 'r';
    debug_msg[len++] = 'n';
    debug_msg[len++] = 'e';
    debug_msg[len++] = 'd';
    debug_msg[len++] = ':';
    debug_msg[len++] = ' ';
    debug_msg[len++] = '0' + (root_node / 10000) % 10;
    debug_msg[len++] = '0' + (root_node / 1000) % 10;
    debug_msg[len++] = '0' + (root_node / 100) % 10;
    debug_msg[len++] = '0' + (root_node / 10) % 10;
    debug_msg[len++] = '0' + root_node % 10;
    debug_msg[len++] = '\n';
    write(1, debug_msg, len);
    
    if (root_node == 0xFFFF || root_node == 0) {
        write(2, "Error: Parsing failed\n", 22);
        return 1;
    }
    
    // Phase 3: Symbol table construction
    write(1, "Phase 3: Building symbols...\n", 29);
    
    write(1, "Allocating symbol table...\n", 28);
    SymbolTable symbol_table;
    write(1, "Symbol table allocated on stack\n", 32);
    
    write(1, "Initializing symbol table...\n", 30);
    symbol_table_init(&symbol_table, string_pool);
    write(1, "Symbol table initialized\n", 25);
    
    write(1, "Building symbol table...\n", 25);
    bool symbol_success = build_symbol_table(&symbol_table, nodes, root_node, (uint16_t)4096, string_pool);
    
    write(1, "Symbol table built.\n", 20);
    
    // Debug: Check nodes after symbol building
    if (nodes[2].type == NODE_FUNC_DEF) {
        print_str("After symbol building: nodes[2].type=");
        print_num(nodes[2].type);
        print_str(" nodes[3].type=");
        print_num(nodes[3].type);
        print_str(" nodes[4].type=");
        print_num(nodes[4].type);
        print_str("\n");
        print_str("  nodes[2].left_idx=");
        print_num(nodes[2].data.binary.left_idx);
        print_str(" right_idx=");
        print_num(nodes[2].data.binary.right_idx);
        print_str("\n");
    }
    
    // Phase 4: Time-travel resolution
    write(1, "Phase 4: Resolving time travel...\n", 34);
    bool time_travel_success = resolve_time_travel(nodes, root_node, (uint16_t)4096, string_pool, execution_plan);
    
    // Debug: Check nodes after time travel
    if (nodes[2].type == NODE_FUNC_DEF || nodes[2].type != NODE_FUNC_DEF) {
        print_str("After time travel: nodes[2].type=");
        print_num(nodes[2].type);
        print_str(" nodes[3].type=");
        print_num(nodes[3].type);
        print_str(" nodes[4].type=");
        print_num(nodes[4].type);
        print_str("\n");
    }
    
    // Phase 5: Code generation
    write(1, "Phase 5: Generating code...\n", 28);
    CodeBuffer code = {
        .code = code_buffer,
        .position = 0,
        .capacity = MAX_CODE_SIZE,
        .temporal_count = 0
    };
    
    // Generate runtime initialization as the very first thing
    extern void generate_runtime_init_minimal(CodeBuffer* buf);
    generate_runtime_init_minimal(&code);
    
    // Initialize variable storage
    extern void generate_var_storage_init(CodeBuffer* buf);
    extern void reset_var_table(void);
    reset_var_table();
    generate_var_storage_init(&code);
    
    // Generate code for each top-level statement
    extern void generate_statement(CodeBuffer* buf, ASTNode* nodes, uint16_t stmt_idx,
                                   SymbolTable* symbols, char* string_pool);
    
    // First pass: separate declared functions from main code
    uint16_t declared_funcs[256];
    uint16_t declared_count = 0;
    uint16_t main_blocks[256];
    uint16_t main_count = 0;
    
    uint16_t stmt = nodes[root_node].data.binary.left_idx;
    while (stmt != 0 && stmt < 4096) {
        print_str("  Checking stmt ");
        print_num(stmt);
        print_str(" type=");
        print_num(nodes[stmt].type);
        print_str(" temporal_offset=");
        print_num(nodes[stmt].data.timing.temporal_offset);
        print_str("\n");
        
        if (nodes[stmt].type == NODE_FUNC_DEF && 
            (nodes[stmt].data.timing.temporal_offset & 0xFFFF) == 1) {
            // Found a declared function (check lower 16 bits for temporal offset)
            if (declared_count < 256) {
                declared_funcs[declared_count++] = stmt;
                print_str("    Added declared function ");
                print_num(stmt);
                print_str("\n");
            }
        } else {
            // Not a declared function, so it's main code
            if (main_count < 256) {
                main_blocks[main_count++] = stmt;
            }
        }
        stmt = nodes[stmt].data.binary.right_idx;
    }
    
    
    print_str("Found ");
    print_num(declared_count);
    print_str(" declared functions and ");
    print_num(main_count);
    print_str(" main statements\n");
    
    // Debug: print all declared functions
    print_str("Declared functions array:\n");
    for (uint16_t i = 0; i < declared_count; i++) {
        print_str("  [");
        print_num(i);
        print_str("] = ");
        print_num(declared_funcs[i]);
        print_str("\n");
    }
    
    // Debug: print all main blocks
    print_str("Main blocks array:\n");
    for (uint16_t i = 0; i < main_count; i++) {
        print_str("  [");
        print_num(i);
        print_str("] = ");
        print_num(main_blocks[i]);
        print_str(" (type=");
        print_num(nodes[main_blocks[i]].type);
        print_str(")\n");
    }
    
    // Emit a jump to skip over all function definitions
    // We'll patch this jump after we know how many bytes the functions take
    print_str("About to emit jump at position ");
    print_num(code.position);
    print_str("\n");
    uint32_t jump_patch_location = code.position;
    emit_byte(&code, 0xE9); // JMP rel32
    emit_dword(&code, 0);   // Placeholder - will patch later
    print_str("Jump emitted, now at position ");
    print_num(code.position);
    print_str("\n");
    
    uint32_t functions_start = code.position;
    
    // Generate all declared function definitions
    // Use a simple check to avoid duplicates
    bool generated[256] = {0};
    
    for (uint16_t i = 0; i < declared_count; i++) {
        uint16_t func = declared_funcs[i];
        
        // Skip if already generated
        if (func < 256 && generated[func]) {
            print_str("Skipping duplicate function ");
            print_num(func);
            print_str("\n");
            continue;
        }
        
        print_str("Generating declared function node ");
        print_num(func);
        print_str(" (type=");
        print_num(nodes[func].type);
        print_str(")\n");
        
        // Double-check the node
        if (func == 2) {
            print_str("  DEBUG: nodes[2].type = ");
            print_num(nodes[2].type);
            print_str(" (expected ");
            print_num(NODE_FUNC_DEF);
            print_str(")\n");
            
            // Check nodes 2, 3, 4 before calling
            print_str("  DEBUG: Before call - nodes[2].type=");
            print_num(nodes[2].type);
            print_str(" nodes[3].type=");
            print_num(nodes[3].type);
            print_str(" nodes[4].type=");
            print_num(nodes[4].type);
            print_str("\n");
            
            // Check the actual memory address
            print_str("  DEBUG: nodes array at ");
            print_num((long)(unsigned long)nodes);
            print_str("\n");
            
            print_str("  DEBUG: About to call generate_statement with func=");
            print_num(func);
            print_str("\n");
        }
        
        if (nodes[func].type == NODE_FUNC_DEF) {
            print_str("  BEFORE CALL: func=");
            print_num(func);
            print_str(" (uint16_t)func=");
            print_num((uint16_t)func);
            print_str("\n");
            generate_statement(&code, nodes, func, &symbol_table, string_pool);
            if (func < 256) generated[func] = true;
        } else {
            print_str("  ERROR: Not a function definition!\n");
        }
    }
    
    uint32_t functions_end = code.position;
    uint32_t main_start = code.position;
    
    // Patch the jump to skip functions
    uint32_t jump_distance = main_start - (jump_patch_location + 5);
    code.code[jump_patch_location + 1] = jump_distance & 0xFF;
    code.code[jump_patch_location + 2] = (jump_distance >> 8) & 0xFF;
    code.code[jump_patch_location + 3] = (jump_distance >> 16) & 0xFF;
    code.code[jump_patch_location + 4] = (jump_distance >> 24) & 0xFF;
    
    print_str("Functions occupy bytes ");
    print_num(functions_start);
    print_str(" to ");
    print_num(functions_end);
    print_str(", jump distance: ");
    print_num(jump_distance);
    print_str("\n");
    
    // Generate all main code (non-declare statements)
    print_str("Generating main code:\n");
    for (uint16_t i = 0; i < main_count; i++) {
        print_str("  Generating main block ");
        print_num(i);
        print_str(" (node ");
        print_num(main_blocks[i]);
        print_str(")\n");
        generate_statement(&code, nodes, main_blocks[i], &symbol_table, string_pool);
    }
    
    // Add platform-specific exit code after all main code
    print_str("Adding exit code at position ");
    print_num(code.position);
    print_str("\n");
    emit_platform_exit(&code, target_platform, 0);
    
    // Keep the old switch for reference (will be removed later)
    if (0) {
        ASTNode* node = &nodes[stmt];
        
        switch (node->type) {
            case NODE_ARRAY_4D_DEF:
                generate_array4d_create(&code, nodes, stmt, &symbol_table, string_pool);
                break;
                
            case NODE_ACTION_BLOCK:
                // Generate action block code
                // Enter arena action block to enable memory cleanup
                extern void generate_arena_enter_action(CodeBuffer* buf);
                extern void generate_arena_exit_action(CodeBuffer* buf);
                generate_arena_enter_action(&code);
                
                uint16_t action = node->data.binary.left_idx;
                while (action != 0 && action < 4096) {
                    // Handle assignments to arrays
                    if (nodes[action].type == NODE_BINARY_OP && 
                        nodes[action].data.binary.op == TOK_MINUS) {
                        uint16_t lhs = nodes[action].data.binary.left_idx;
                        if (nodes[lhs].type == NODE_ARRAY_4D_ACCESS) {
                            // Array assignment
                            generate_array4d_access(&code, nodes, lhs, 
                                                  &symbol_table, string_pool, true);
                        }
                    }
                    action = nodes[action].data.binary.right_idx;
                }
                
                // Exit arena action block - all temporaries are freed
                generate_arena_exit_action(&code);
                break;
                
            case NODE_JUMP:
                // Timeline operations (jump, bounce, etc.)
                gen_timeline_operation(code.code, &code.position, node, 
                                     string_pool, &symbol_table);
                break;
                
            case NODE_TIMING_OP:
                // Timeline merge/queue operations
                gen_timeline_operation(code.code, &code.position, node,
                                     string_pool, &symbol_table);
                break;
                
            case NODE_OUTPUT:
                // Output methods (print, txt, out, fmt, dyn)
                gen_output_method(code.code, &code.position, node,
                                string_pool, &symbol_table);
                break;
                
            case NODE_INLINE_ASM:
                // Direct assembly code insertion
                gen_inline_asm(code.code, &code.position, node,
                              string_pool, &symbol_table);
                break;
                
            default:
                // Other statement types
                break;
        }
        
        stmt = nodes[stmt].data.binary.right_idx;
    }
    
    // Don't clean up stack frame - we're exiting directly
    // The exit syscall will terminate the process
    
    // Add platform-specific exit code
    emit_platform_exit(&code, target_platform, 0);
    
    // Phase 6: Generate executable(s)
    write(1, "Phase 6: Generating executable...\n", 34);
    
    if (generate_both) {
        // Generate both Windows and Linux executables
        char win_name[256];
        char linux_name[256];
        
        // Build filenames
        int i = 0;
        while (output_name[i] && i < 250) {
            win_name[i] = output_name[i];
            linux_name[i] = output_name[i];
            i++;
        }
        win_name[i] = '.'; win_name[i+1] = 'e'; win_name[i+2] = 'x'; win_name[i+3] = 'e'; win_name[i+4] = '\0';
        linux_name[i] = '\0';
        
        generate_pe_executable(code_buffer, code.position, win_name);
        generate_elf_executable(code_buffer, code.position, linux_name);
        
        write(1, "Generated executables for both platforms!\n", 42);
    } else {
        // Generate single platform executable
        char out_file[256];
        int i = 0;
        while (output_name[i] && i < 250) {
            out_file[i] = output_name[i];
            i++;
        }
        
        if (target_platform == PLATFORM_WINDOWS) {
            out_file[i] = '.'; out_file[i+1] = 'e'; out_file[i+2] = 'x'; out_file[i+3] = 'e'; out_file[i+4] = '\0';
            generate_pe_executable(code_buffer, code.position, out_file);
        } else {
            out_file[i] = '\0';
            generate_elf_executable(code_buffer, code.position, out_file);
        }
        
        write(1, "Generated ", 10);
        write(1, get_platform_name(target_platform), str_len(get_platform_name(target_platform)));
        write(1, " executable!\n", 13);
    }
    
    write(1, "Compilation successful!\n", 24);
    
    // Show usage
    write(1, "\nUsage: ", 8);
    write(1, argv[0], str_len(argv[0]));
    write(1, " <source.blaze> [-o output] [-p w|l|m] [-a]\n", 45);
    write(1, "  -o output   Set output filename\n", 34);
    write(1, "  -p w|l|m    Target platform (windows/linux/macos)\n", 52);
    write(1, "  -a          Generate executables for all platforms\n", 53);
    
    return 0;
}

// Add missing declarations
extern const char* get_platform_name(Platform platform);