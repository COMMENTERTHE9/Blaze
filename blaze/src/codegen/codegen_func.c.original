// FUNCTION DEFINITION AND CALL CODE GENERATION
// Handles |name| entry.can< :> function definitions and ^name/ calls

#include "blaze_internals.h"

// Function symbol table entry
typedef struct {
    uint32_t name_hash;
    uint32_t code_offset;  // Offset in code buffer where function starts
    uint16_t param_count;
    bool is_defined;
} FunctionEntry;

// Global function table (simple for now)
static FunctionEntry function_table[256];
static uint16_t function_count = 0;

// Hash function name for lookup
static uint32_t hash_string(const char* str) {
    uint32_t hash = 5381;
    while (*str) {
        hash = ((hash << 5) + hash) + *str++;
    }
    return hash;
}

// Register or create function entry
static FunctionEntry* get_or_create_function(const char* name) {
    uint32_t hash = hash_string(name);
    
    // Linear search for now
    for (uint16_t i = 0; i < function_count; i++) {
        if (function_table[i].name_hash == hash) {
            return &function_table[i];
        }
    }
    
    // Create new entry
    if (function_count < 256) {
        FunctionEntry* entry = &function_table[function_count++];
        entry->name_hash = hash;
        entry->code_offset = 0;
        entry->param_count = 0;
        entry->is_defined = false;
        return entry;
    }
    
    return NULL;
}

// Forward declaration for statement generation
extern void generate_statement(CodeBuffer* buf, ASTNode* nodes, uint16_t stmt_idx, 
                             SymbolTable* symbols, char* string_pool);

// Generate function prologue
static void emit_function_prologue(CodeBuffer* buf) {
    // push rbp
    emit_push_reg(buf, RBP);
    // mov rbp, rsp
    emit_mov_reg_reg(buf, RBP, RSP);
    // Optionally: sub rsp, N for local variables
}

// Generate function epilogue  
static void emit_function_epilogue(CodeBuffer* buf) {
    // mov rsp, rbp
    emit_mov_reg_reg(buf, RSP, RBP);
    // pop rbp
    emit_pop_reg(buf, RBP);
    // ret
    emit_ret(buf);
}

// Generate code for function definition
void generate_func_def(CodeBuffer* buf, ASTNode* nodes, uint16_t func_idx, 
                      SymbolTable* symbols, char* string_pool) {
    // Debug output
    print_str("generate_func_def called with:\n");
    print_str("  func_idx = ");
    print_num((long)func_idx);
    print_str("\n");
    
    if (func_idx == 0 || func_idx >= 4096) {
        print_str("  ERROR: Invalid function index\n");
        return;
    }
    
    ASTNode* func_node = &nodes[func_idx];
    if (func_node->type != NODE_FUNC_DEF) {
        print_str("  ERROR: Not a function definition node\n");
        return;
    }
    
    // Get function name from right_idx (as per parser structure)
    uint16_t name_idx = func_node->data.binary.right_idx;
    if (name_idx == 0 || name_idx >= 4096) {
        print_str("  ERROR: Invalid name index\n");
        return;
    }
    
    ASTNode* name_node = &nodes[name_idx];
    if (name_node->type != NODE_IDENTIFIER) {
        print_str("  ERROR: Function name is not an identifier\n");
        return;
    }
    
    const char* func_name = &string_pool[name_node->data.ident.name_offset];
    print_str("  Function name: ");
    print_str(func_name);
    print_str("\n");
    
    // Get or create function entry
    FunctionEntry* entry = get_or_create_function(func_name);
    if (!entry) {
        print_str("  ERROR: Could not create function entry\n");
        return;
    }
    
    if (entry->is_defined) {
        print_str("  ERROR: Function '");
        print_str(func_name);
        print_str("' already defined\n");
        return;
    }
    
    // Mark function location
    entry->code_offset = buf->position;
    entry->is_defined = true;
    
    print_str("  Function '");
    print_str(func_name);
    print_str("' starts at offset ");
    print_num((long)entry->code_offset);
    print_str("\n");
    
    // Generate function prologue
    emit_function_prologue(buf);
    
    // Get function body from left_idx (as per parser structure)
    uint16_t body_idx = func_node->data.binary.left_idx;
    if (body_idx != 0 && body_idx < 4096) {
        print_str("  Processing function body at index ");
        print_num((long)body_idx);
        print_str("\n");
        
        // Generate code for function body
        // The body is an action block, which is a chain of statements
        generate_statement(buf, nodes, body_idx, symbols, string_pool);
    } else {
        print_str("  Function has empty body\n");
    }
    
    // Generate function epilogue
    emit_function_epilogue(buf);
    
    print_str("  Function '");
    print_str(func_name);
    print_str("' generated ");
    print_num((long)(buf->position - entry->code_offset));
    print_str(" bytes\n");
}

// Generate code for function call
void generate_func_call(CodeBuffer* buf, ASTNode* nodes, uint16_t call_idx,
                       SymbolTable* symbols, char* string_pool) {
    // Debug output
    print_str("generate_func_call: call_idx=");
    print_num((long)call_idx);
    print_str("\n");
    
    if (call_idx == 0 || call_idx >= 4096) {
        print_str("  ERROR: Invalid call index\n");
        return;
    }
    
    ASTNode* call_node = &nodes[call_idx];
    if (call_node->type != NODE_FUNC_CALL) {
        print_str("  ERROR: Not a function call node\n");
        return;
    }
    
    // Get function name from left_idx
    uint16_t name_idx = call_node->data.binary.left_idx;
    if (name_idx == 0 || name_idx >= 4096) {
        print_str("  ERROR: Invalid name index in call\n");
        return;
    }
    
    ASTNode* name_node = &nodes[name_idx];
    if (name_node->type != NODE_IDENTIFIER) {
        print_str("  ERROR: Function name is not an identifier\n");
        return;
    }
    
    const char* func_name = &string_pool[name_node->data.ident.name_offset];
    print_str("  Calling function: ");
    print_str(func_name);
    print_str("\n");
    
    // Look up function
    FunctionEntry* entry = get_or_create_function(func_name);
    if (!entry) {
        print_str("  ERROR: Could not find/create function entry\n");
        return;
    }
    
    // TODO: Handle parameters from right_idx
    // For now assume no parameters
    
    // Save volatile registers per System V ABI
    emit_push_reg(buf, RAX);
    emit_push_reg(buf, RCX);
    emit_push_reg(buf, RDX);
    emit_push_reg(buf, RSI);
    emit_push_reg(buf, RDI);
    emit_push_reg(buf, R8);
    emit_push_reg(buf, R9);
    emit_push_reg(buf, R10);
    emit_push_reg(buf, R11);
    
    if (entry->is_defined) {
        // Function is already defined, calculate relative offset
        print_str("  Function '");
        print_str(func_name);
        print_str("' is at offset ");
        print_num((long)entry->code_offset);
        print_str(", current position is ");
        print_num((long)buf->position);
        print_str("\n");
        
        // The call instruction is 5 bytes: 0xE8 + 4-byte offset
        // The offset is calculated from the END of the call instruction
        int32_t offset = entry->code_offset - (buf->position + 5);
        print_str("  Calculated jump offset: ");
        print_num((long)offset);
        print_str("\n");
        
        emit_byte(buf, 0xE8); // CALL rel32
        emit_dword(buf, offset);
    } else {
        // Forward reference - will need fixup later
        print_str("  WARNING: Forward reference to undefined function '");
        print_str(func_name);
        print_str("'\n");
        
        // For now, emit a placeholder that will cause visible error
        emit_byte(buf, 0xE8); // CALL rel32
        emit_dword(buf, 0xDEADBEEF); // Obvious placeholder
    }
    
    // Restore volatile registers
    emit_pop_reg(buf, R11);
    emit_pop_reg(buf, R10);
    emit_pop_reg(buf, R9);
    emit_pop_reg(buf, R8);
    emit_pop_reg(buf, RDI);
    emit_pop_reg(buf, RSI);
    emit_pop_reg(buf, RDX);
    emit_pop_reg(buf, RCX);
    emit_pop_reg(buf, RAX);
    
    print_str("  Function call complete\n");
}